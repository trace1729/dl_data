[
  {
    "question": "module alu (\n  input [31:0] a, b,\n  input [3:0] op,\n  output reg [31:0] result\n);\n  reg [31:0] add_result, sub_result;\n  \n  always @(*) begin\n    add_result = a + b;\n    sub_result = a - b;\n    \n    case (op)\n      4'b0000: result = add_result;\n      4'b0001: result = sub_result;\n      4'b0010: result = a & b;\n      4'b0011: result = a | b;\n      4'b0100: result = a ^ b;\n      4'b0101: result = a << b[4:0];\n      4'b0110: result = a >> b[4:0];\n      4'b0111: result = $signed(a) >>> b[4:0];\n      default: result = 32'b0;\n    endcase\n  end\nendmodule",
    "answer": {
      "Performance": "The current design uses separate adder and subtractor units, increasing critical path delay. Optimize by reusing a single adder for subtraction using two's complement: invert B's bits and set carry-in to 1. Example:\n\nreg carry_in;\nreg [31:0] b_mod;\nalways @(*) begin\n  carry_in = (op == 4'b0001) ? 1'b1 : 1'b0;\n  b_mod = (op == 4'b0001) ? ~b : b;\n  add_sub_result = a + b_mod + carry_in;\n  \n  case (op)\n    4'b0000, 4'b0001: result = add_sub_result;\n    // other operations unchanged\n  endcase\nend\n\nThis reduces critical path by having only one addition circuit instead of two separate units.",
      "Power": "Computing both addition and subtraction simultaneously wastes power since only one is used per operation. The optimized design computes only what's needed, reducing switching activity by ~50% for these operations. Also consider adding operand isolation (gating unused operation paths) to prevent unnecessary transitions.",
      "Area": "Using a shared adder for both addition and subtraction reduces logic area significantly. Subtraction can be implemented with just additional input-stage XOR gates and a carry-in, saving approximately 30-40% area in the arithmetic portion of the ALU compared to having separate adders."
    }
  },
  {
    "question": "module pipeline_cpu (\n  input clk, reset,\n  // other ports\n);\n  // Pipeline registers\n  reg [31:0] if_id_ir, if_id_pc;\n  reg [31:0] id_ex_ir, id_ex_a, id_ex_b, id_ex_imm;\n  reg [31:0] ex_mem_ir, ex_mem_aluout;\n  reg [31:0] mem_wb_ir, mem_wb_aluout, mem_wb_memout;\n  \n  // Hazard detection\n  always @(*) begin\n    // Load-use hazard\n    if ((id_ex_ir[31:26] == 6'b100011) && // load instruction\n        ((id_ex_ir[20:16] == if_id_ir[25:21]) || \n         (id_ex_ir[20:16] == if_id_ir[20:16]))) begin\n      stall = 1'b1;\n    end else begin\n      stall = 1'b0;\n    end\n  end\n  \n  // No forwarding implementation\nendmodule",
    "answer": {
      "Performance": "This pipeline stalls on all load instructions that have RAW dependencies, even when forwarding could eliminate many stalls. Implement data forwarding paths from EX/MEM and MEM/WB stages to the ALU inputs:\n\nalways @(*) begin\n  // Forward A\n  if (ex_mem_regwrite && (ex_mem_rd != 0) && (ex_mem_rd == id_ex_rs))\n    forwardA = 2'b10; // Forward from EX/MEM\n  else if (mem_wb_regwrite && (mem_wb_rd != 0) && (mem_wb_rd == id_ex_rs))\n    forwardA = 2'b01; // Forward from MEM/WB\n  else\n    forwardA = 2'b00; // No forwarding\n  \n  // Similar logic for forwardB\n\n  // Only stall on load-use hazards when forwarding can't help\n  stall = (id_ex_memread && \n          ((id_ex_rt == if_id_rs) || (id_ex_rt == if_id_rt)));\nend\n\nThis reduces stalls by ~30-40% in typical code sequences.",
      "Power": "Excessive stalling wastes power by performing unnecessary register updates and clock toggles without useful work. With forwarding, the CPU stalls less frequently, improving instructions-per-cycle and energy efficiency. CPU utilization will be higher, resulting in less idle power consumption per computation.",
      "Area": "Adding forwarding logic increases area slightly by adding multiplexers (2-to-1 or 3-to-1) at ALU inputs and hazard detection comparators. However, the area increase is minimal (typically <5% of CPU area) compared to the significant performance benefit of reducing pipeline bubbles."
    }
  },
  {
    "question": "module branch_resolver (\n  input clk, reset,\n  input [31:0] instruction,\n  input [31:0] rs_data, rt_data,\n  output reg take_branch\n);\n  \n  always @(*) begin\n    case (instruction[31:26])\n      6'b000100: take_branch = (rs_data == rt_data); // BEQ\n      6'b000101: take_branch = (rs_data != rt_data); // BNE\n      6'b000001: begin // BLTZ, BGEZ\n        case (instruction[20:16])\n          5'b00000: take_branch = $signed(rs_data) < 0; // BLTZ\n          5'b00001: take_branch = $signed(rs_data) >= 0; // BGEZ\n          default: take_branch = 1'b0;\n        endcase\n      end\n      default: take_branch = 1'b0;\n    endcase\n  end\n\n  // Branch is resolved in Execute stage\n  // Pipeline stalls until branch decision is made\nendmodule",
    "answer": {
      "Performance": "The branch resolution happens late in the pipeline (Execute stage), causing stalls for every branch. Move branch resolution to the Decode stage by adding a dedicated branch comparator:\n\nalways @(*) begin\n  // Early branch resolution in decode stage\n  case (if_id_instruction[31:26])\n    6'b000100: br_taken = (id_rs_data == id_rt_data); // BEQ\n    6'b000101: br_taken = (id_rs_data != id_rt_data); // BNE\n    // other branch types...\n  endcase\nend\n\nThis eliminates the branch resolution delay, removing 1-2 bubble cycles per branch. You can further optimize by adding a simple branch predictor (e.g., 2-bit saturating counter) to reduce stalls when predictions are correct.",
      "Power": "Frequent pipeline stalls waste power cycling idle stages. Early branch resolution plus branch prediction reduces unnecessary fetches and execution of instructions that will be flushed. Adding a Branch Target Buffer (BTB) can save even more power by avoiding fetches from incorrect paths.",
      "Area": "Early branch resolution requires additional comparators in the decode stage, slightly increasing area. Adding a simple branch predictor (128-256 entry, 2-bit counter) adds modest area (~0.5-1KB) but yields significant performance gain. The area increase is justifiable given the performance improvement for branch-heavy code."
    }
  },
  {
    "question": "module shifter (\n  input [31:0] data_in,\n  input [4:0] shift_amount,\n  input [1:0] shift_type, // 00:logical left, 01:logical right, 10:arithmetic right\n  output reg [31:0] data_out\n);\n  \n  integer i;\n  always @(*) begin\n    data_out = data_in;\n    \n    case (shift_type)\n      2'b00: begin // Logical left shift\n        for (i = 0; i < shift_amount; i = i + 1) begin\n          data_out = {data_out[30:0], 1'b0};\n        end\n      end\n      2'b01: begin // Logical right shift\n        for (i = 0; i < shift_amount; i = i + 1) begin\n          data_out = {1'b0, data_out[31:1]};\n        end\n      end\n      2'b10: begin // Arithmetic right shift\n        for (i = 0; i < shift_amount; i = i + 1) begin\n          data_out = {data_out[31], data_out[31:1]};\n        end\n      end\n      default: data_out = data_in;\n    endcase\n  end\nendmodule",
    "answer": {
      "Performance": "The iterative shift implementation creates a long combinational path with O(n) delay where n is shift_amount. Replace with a barrel shifter implementation using cascaded multiplexers for O(log n) delay:\n\nreg [31:0] stage1, stage2, stage4, stage8, stage16;\nalways @(*) begin\n  // Stage shifts by 1 if shift_amount[0] = 1\n  stage1 = shift_amount[0] ? \n    (shift_type == 2'b00 ? {data_in[30:0], 1'b0} : \n     shift_type == 2'b01 ? {1'b0, data_in[31:1]} : \n     {data_in[31], data_in[31:1]}) : data_in;\n  \n  // Stage shifts by 2 if shift_amount[1] = 1\n  stage2 = shift_amount[1] ? \n    (shift_type == 2'b00 ? {stage1[29:0], 2'b0} : \n     shift_type == 2'b01 ? {2'b0, stage1[31:2]} : \n     {2{stage1[31]}, stage1[31:2]}) : stage1;\n  \n  // Continue for 4, 8, and 16 bit shifts\n  // ...\n  \n  data_out = stage16;\nend\n\nThis reduces critical path delay from O(32) to O(5) = O(log 32).",
      "Power": "The iterative approach causes excessive switching as data ripples through each iteration. The barrel shifter approach reduces switching activity significantly by having data flow through exactly 5 stages regardless of shift amount. Consider adding operand isolation when shift_amount=0 to avoid unnecessary toggling.",
      "Area": "The barrel shifter uses more multiplexers at first glance, but synthesis tools struggle to optimize the iterative loop efficiently. The barrel shifter implementation gives the synthesizer a clear structure to optimize. Overall area may increase slightly, but the performance gain justifies this trade-off, and modern synthesis tools optimize barrel shifters well."
    }
  },
  {
    "question": "module hazard_unit (\n  input [4:0] id_ex_rt,\n  input id_ex_memread,\n  input [4:0] if_id_rs,\n  input [4:0] if_id_rt,\n  output reg stall\n);\n  \n  always @(*) begin\n    if (id_ex_memread && \n        ((id_ex_rt == if_id_rs) || (id_ex_rt == if_id_rt))) begin\n      stall = 1'b1; // Stall on load-use hazard\n    end else begin\n      stall = 1'b0;\n    end\n  end\nendmodule",
    "answer": {
      "Performance": "This hazard unit conservatively stalls for all load-use hazards, even when the subsequent instruction doesn't actually use the loaded value. Optimize by checking if the loaded register is actually needed:\n\nalways @(*) begin\n  // Check if it's a load instruction\n  if (id_ex_memread) begin\n    // Check if it's a RAW hazard AND the value is actually needed\n    if ((id_ex_rt == if_id_rs && if_id_rs_used) || \n        (id_ex_rt == if_id_rt && if_id_rt_used)) begin\n      stall = 1'b1;\n    end else begin\n      stall = 1'b0;\n    end\n  end else begin\n    stall = 1'b0;\n  end\nend\n\nAdd signals 'if_id_rs_used' and 'if_id_rt_used' based on instruction type. For example, immediate instructions don't use rt, and some operations (like lui) don't use rs.",
      "Power": "Unnecessary stalls waste power by extending program execution time and keeping the pipeline active without useful work. The optimized hazard detection reduces stalls by ~15-20% for typical code, which directly translates to power savings from higher throughput and fewer cycles spent in stall states.",
      "Area": "This optimization adds minimal additional logic (instruction decode bits to determine register usage). The area overhead is negligible (a few gates) compared to the performance benefit of reducing unnecessary stalls. The implementation can reuse instruction decode logic that likely exists elsewhere in the CPU."
    }
  },
  {
    "question": "module alu_control (\n  input [5:0] funct,\n  input [1:0] alu_op,\n  output reg [3:0] alu_control\n);\n  \n  always @(*) begin\n    case (alu_op)\n      2'b00: alu_control = 4'b0010; // add for load/store\n      2'b01: alu_control = 4'b0110; // sub for branches\n      2'b10: begin // R-type instructions\n        case (funct)\n          6'b100000: alu_control = 4'b0010; // add\n          6'b100010: alu_control = 4'b0110; // sub\n          6'b100100: alu_control = 4'b0000; // and\n          6'b100101: alu_control = 4'b0001; // or\n          6'b101010: alu_control = 4'b0111; // slt\n          default: alu_control = 4'bxxxx; // undefined\n        endcase\n      end\n      default: alu_control = 4'bxxxx; // undefined\n    endcase\n  end\nendmodule",
    "answer": {
      "Performance": "The current design has undefined outputs (4'bxxxx) which can cause simulation issues and unpredictable synthesis results. Also, the nested case statements create a deep logic tree that increases delay. Flatten the logic and add a default value:\n\nalways @(*) begin\n  // Default assignment\n  alu_control = 4'b0000;\n  \n  case ({alu_op, funct})\n    // Load/store operations\n    {2'b00, 6'bxxxxxx}: alu_control = 4'b0010; // add\n    \n    // Branch operations\n    {2'b01, 6'bxxxxxx}: alu_control = 4'b0110; // sub\n    \n    // R-type operations\n    {2'b10, 6'b100000}: alu_control = 4'b0010; // add\n    {2'b10, 6'b100010}: alu_control = 4'b0110; // sub\n    {2'b10, 6'b100100}: alu_control = 4'b0000; // and\n    {2'b10, 6'b100101}: alu_control = 4'b0001; // or\n    {2'b10, 6'b101010}: alu_control = 4'b0111; // slt\n    // Add other instructions as needed\n  endcase\nend\n\nThis flattened approach reduces logic levels in the critical path.",
      "Power": "The 'x' states can cause excessive toggling in simulation and unpredictable power behavior in synthesis. Adding a default assignment prevents unwanted switching. A lookup table (LUT) implementation is more power-efficient than the cascaded case statements in the original design, as fewer gates toggle during operation.",
      "Area": "The flattened case statement allows the synthesis tool to better optimize the logic, potentially reducing the area. Adding a default assignment prevents the synthesis tool from inferring latches, which would consume unnecessary area. For a small control unit like this, the area impact is minimal but important for clean synthesis."
    }
  },

  {
    "question": "module register_file (\n  input clk, reset,\n  input [4:0] read_addr1, read_addr2, write_addr,\n  input [31:0] write_data,\n  input write_enable,\n  output [31:0] read_data1, read_data2\n);\n  reg [31:0] regs [0:31];\n  integer i;\n  \n  // Reset all registers\n  always @(posedge clk) begin\n    if (reset) begin\n      for (i = 0; i < 32; i = i + 1) begin\n        regs[i] <= 32'b0;\n      end\n    end else if (write_enable && write_addr != 5'b0) begin\n      regs[write_addr] <= write_data;\n    end\n  end\n  \n  // Read operations\n  assign read_data1 = regs[read_addr1];\n  assign read_data2 = regs[read_addr2];\nendmodule",
    "answer": {
      "Performance": "Resetting all 32 registers on every reset creates a long initialization period. Since register values are undefined at startup and will be written before read in proper code, only reset critical registers or remove the reset loop entirely:\n\nalways @(posedge clk) begin\n  if (write_enable && write_addr != 5'b0) begin\n    regs[write_addr] <= write_data;\n  end\nend\n\nAlternatively, reset only specific registers:\n\nalways @(posedge clk) begin\n  if (reset) begin\n    regs[0] <= 32'b0; // Example: reset only register 0\n  end\nend",
      "Power": "Resetting all registers unnecessarily toggles many flip-flops, wasting power. Reset only critical registers or use asynchronous reset for specific registers to reduce power consumption during reset.",
      "Area": "The current design uses a loop to reset all registers, which may infer additional logic. Reducing the reset logic to only critical registers or removing it entirely can save area, especially in designs where reset is not required for all registers."
    }
  },
  {
    "question": "module alu (\n  input [31:0] a, b,\n  input [3:0] op,\n  output reg [31:0] result\n);\n  reg [31:0] add_result, sub_result;\n  \n  always @(*) begin\n    add_result = a + b;\n    sub_result = a - b;\n    \n    case (op)\n      4'b0000: result = add_result;\n      4'b0001: result = sub_result;\n      4'b0010: result = a & b;\n      4'b0011: result = a | b;\n      4'b0100: result = a ^ b;\n      4'b0101: result = a << b[4:0];\n      4'b0110: result = a >> b[4:0];\n      4'b0111: result = $signed(a) >>> b[4:0];\n      default: result = 32'b0;\n    endcase\n  end\nendmodule",
    "answer": {
      "Performance": "The current design uses separate adder and subtractor units, increasing critical path delay. Optimize by reusing a single adder for subtraction using two's complement: invert B's bits and set carry-in to 1. Example:\n\nreg carry_in;\nreg [31:0] b_mod;\nalways @(*) begin\n  carry_in = (op == 4'b0001) ? 1'b1 : 1'b0;\n  b_mod = (op == 4'b0001) ? ~b : b;\n  add_sub_result = a + b_mod + carry_in;\n  \n  case (op)\n    4'b0000, 4'b0001: result = add_sub_result;\n    // other operations unchanged\n  endcase\nend\n\nThis reduces critical path by having only one addition circuit instead of two separate units.",
      "Power": "Computing both addition and subtraction simultaneously wastes power since only one is used per operation. The optimized design computes only what's needed, reducing switching activity by ~50% for these operations. Also consider adding operand isolation (gating unused operation paths) to prevent unnecessary transitions.",
      "Area": "Using a shared adder for both addition and subtraction reduces logic area significantly. Subtraction can be implemented with just additional input-stage XOR gates and a carry-in, saving approximately 30-40% area in the arithmetic portion of the ALU compared to having separate adders."
    }
  },
  {
    "question": "module pipeline_cpu (\n  input clk, reset,\n  // other ports\n);\n  // Pipeline registers\n  reg [31:0] if_id_ir, if_id_pc;\n  reg [31:0] id_ex_ir, id_ex_a, id_ex_b, id_ex_imm;\n  reg [31:0] ex_mem_ir, ex_mem_aluout;\n  reg [31:0] mem_wb_ir, mem_wb_aluout, mem_wb_memout;\n  \n  // Hazard detection\n  always @(*) begin\n    // Load-use hazard\n    if ((id_ex_ir[31:26] == 6'b100011) && // load instruction\n        ((id_ex_ir[20:16] == if_id_ir[25:21]) || \n         (id_ex_ir[20:16] == if_id_ir[20:16]))) begin\n      stall = 1'b1;\n    end else begin\n      stall = 1'b0;\n    end\n  end\n  \n  // No forwarding implementation\nendmodule",
    "answer": {
      "Performance": "This pipeline stalls on all load instructions that have RAW dependencies, even when forwarding could eliminate many stalls. Implement data forwarding paths from EX/MEM and MEM/WB stages to the ALU inputs:\n\nalways @(*) begin\n  // Forward A\n  if (ex_mem_regwrite && (ex_mem_rd != 0) && (ex_mem_rd == id_ex_rs))\n    forwardA = 2'b10; // Forward from EX/MEM\n  else if (mem_wb_regwrite && (mem_wb_rd != 0) && (mem_wb_rd == id_ex_rs))\n    forwardA = 2'b01; // Forward from MEM/WB\n  else\n    forwardA = 2'b00; // No forwarding\n  \n  // Similar logic for forwardB\n\n  // Only stall on load-use hazards when forwarding can't help\n  stall = (id_ex_memread && \n          ((id_ex_rt == if_id_rs) || (id_ex_rt == if_id_rt)));\nend\n\nThis reduces stalls by ~30-40% in typical code sequences.",
      "Power": "Excessive stalling wastes power by performing unnecessary register updates and clock toggles without useful work. With forwarding, the CPU stalls less frequently, improving instructions-per-cycle and energy efficiency. CPU utilization will be higher, resulting in less idle power consumption per computation.",
      "Area": "Adding forwarding logic increases area slightly by adding multiplexers (2-to-1 or 3-to-1) at ALU inputs and hazard detection comparators. However, the area increase is minimal (typically <5% of CPU area) compared to the significant performance benefit of reducing pipeline bubbles."
    }
  },
  {
    "question": "module branch_resolver (\n  input clk, reset,\n  input [31:0] instruction,\n  input [31:0] rs_data, rt_data,\n  output reg take_branch\n);\n  \n  always @(*) begin\n    case (instruction[31:26])\n      6'b000100: take_branch = (rs_data == rt_data); // BEQ\n      6'b000101: take_branch = (rs_data != rt_data); // BNE\n      6'b000001: begin // BLTZ, BGEZ\n        case (instruction[20:16])\n          5'b00000: take_branch = $signed(rs_data) < 0; // BLTZ\n          5'b00001: take_branch = $signed(rs_data) >= 0; // BGEZ\n          default: take_branch = 1'b0;\n        endcase\n      end\n      default: take_branch = 1'b0;\n    endcase\n  end\n\n  // Branch is resolved in Execute stage\n  // Pipeline stalls until branch decision is made\nendmodule",
    "answer": {
      "Performance": "The branch resolution happens late in the pipeline (Execute stage), causing stalls for every branch. Move branch resolution to the Decode stage by adding a dedicated branch comparator:\n\nalways @(*) begin\n  // Early branch resolution in decode stage\n  case (if_id_instruction[31:26])\n    6'b000100: br_taken = (id_rs_data == id_rt_data); // BEQ\n    6'b000101: br_taken = (id_rs_data != id_rt_data); // BNE\n    // other branch types...\n  endcase\nend\n\nThis eliminates the branch resolution delay, removing 1-2 bubble cycles per branch. You can further optimize by adding a simple branch predictor (e.g., 2-bit saturating counter) to reduce stalls when predictions are correct.",
      "Power": "Frequent pipeline stalls waste power cycling idle stages. Early branch resolution plus branch prediction reduces unnecessary fetches and execution of instructions that will be flushed. Adding a Branch Target Buffer (BTB) can save even more power by avoiding fetches from incorrect paths.",
      "Area": "Early branch resolution requires additional comparators in the decode stage, slightly increasing area. Adding a simple branch predictor (128-256 entry, 2-bit counter) adds modest area (~0.5-1KB) but yields significant performance gain. The area increase is justifiable given the performance improvement for branch-heavy code."
    }
  },
  {
    "question": "module shifter (\n  input [31:0] data_in,\n  input [4:0] shift_amount,\n  input [1:0] shift_type, // 00:logical left, 01:logical right, 10:arithmetic right\n  output reg [31:0] data_out\n);\n  \n  integer i;\n  always @(*) begin\n    data_out = data_in;\n    \n    case (shift_type)\n      2'b00: begin // Logical left shift\n        for (i = 0; i < shift_amount; i = i + 1) begin\n          data_out = {data_out[30:0], 1'b0};\n        end\n      end\n      2'b01: begin // Logical right shift\n        for (i = 0; i < shift_amount; i = i + 1) begin\n          data_out = {1'b0, data_out[31:1]};\n        end\n      end\n      2'b10: begin // Arithmetic right shift\n        for (i = 0; i < shift_amount; i = i + 1) begin\n          data_out = {data_out[31], data_out[31:1]};\n        end\n      end\n      default: data_out = data_in;\n    endcase\n  end\nendmodule",
    "answer": {
      "Performance": "The iterative shift implementation creates a long combinational path with O(n) delay where n is shift_amount. Replace with a barrel shifter implementation using cascaded multiplexers for O(log n) delay:\n\nreg [31:0] stage1, stage2, stage4, stage8, stage16;\nalways @(*) begin\n  // Stage shifts by 1 if shift_amount[0] = 1\n  stage1 = shift_amount[0] ? \n    (shift_type == 2'b00 ? {data_in[30:0], 1'b0} : \n     shift_type == 2'b01 ? {1'b0, data_in[31:1]} : \n     {data_in[31], data_in[31:1]}) : data_in;\n  \n  // Stage shifts by 2 if shift_amount[1] = 1\n  stage2 = shift_amount[1] ? \n    (shift_type == 2'b00 ? {stage1[29:0], 2'b0} : \n     shift_type == 2'b01 ? {2'b0, stage1[31:2]} : \n     {2{stage1[31]}, stage1[31:2]}) : stage1;\n  \n  // Continue for 4, 8, and 16 bit shifts\n  // ...\n  \n  data_out = stage16;\nend\n\nThis reduces critical path delay from O(32) to O(5) = O(log 32).",
      "Power": "The iterative approach causes excessive switching as data ripples through each iteration. The barrel shifter approach reduces switching activity significantly by having data flow through exactly 5 stages regardless of shift amount. Consider adding operand isolation when shift_amount=0 to avoid unnecessary toggling.",
      "Area": "The barrel shifter uses more multiplexers at first glance, but synthesis tools struggle to optimize the iterative loop efficiently. The barrel shifter implementation gives the synthesizer a clear structure to optimize. Overall area may increase slightly, but the performance gain justifies this trade-off, and modern synthesis tools optimize barrel shifters well."
    }
  },
  {
    "question": "module hazard_unit (\n  input [4:0] id_ex_rt,\n  input id_ex_memread,\n  input [4:0] if_id_rs,\n  input [4:0] if_id_rt,\n  output reg stall\n);\n  \n  always @(*) begin\n    if (id_ex_memread && \n        ((id_ex_rt == if_id_rs) || (id_ex_rt == if_id_rt))) begin\n      stall = 1'b1; // Stall on load-use hazard\n    end else begin\n      stall = 1'b0;\n    end\n  end\nendmodule",
    "answer": {
      "Performance": "This hazard unit conservatively stalls for all load-use hazards, even when the subsequent instruction doesn't actually use the loaded value. Optimize by checking if the loaded register is actually needed:\n\nalways @(*) begin\n  // Check if it's a load instruction\n  if (id_ex_memread) begin\n    // Check if it's a RAW hazard AND the value is actually needed\n    if ((id_ex_rt == if_id_rs && if_id_rs_used) || \n        (id_ex_rt == if_id_rt && if_id_rt_used)) begin\n      stall = 1'b1;\n    end else begin\n      stall = 1'b0;\n    end\n  end else begin\n    stall = 1'b0;\n  end\nend\n\nAdd signals 'if_id_rs_used' and 'if_id_rt_used' based on instruction type. For example, immediate instructions don't use rt, and some operations (like lui) don't use rs.",
      "Power": "Unnecessary stalls waste power by extending program execution time and keeping the pipeline active without useful work. The optimized hazard detection reduces stalls by ~15-20% for typical code, which directly translates to power savings from higher throughput and fewer cycles spent in stall states.",
      "Area": "This optimization adds minimal additional logic (instruction decode bits to determine register usage). The area overhead is negligible (a few gates) compared to the performance benefit of reducing unnecessary stalls. The implementation can reuse instruction decode logic that likely exists elsewhere in the CPU."
    }
  },
  {
    "question": "module alu_control (\n  input [5:0] funct,\n  input [1:0] alu_op,\n  output reg [3:0] alu_control\n);\n  \n  always @(*) begin\n    case (alu_op)\n      2'b00: alu_control = 4'b0010; // add for load/store\n      2'b01: alu_control = 4'b0110; // sub for branches\n      2'b10: begin // R-type instructions\n        case (funct)\n          6'b100000: alu_control = 4'b0010; // add\n          6'b100010: alu_control = 4'b0110; // sub\n          6'b100100: alu_control = 4'b0000; // and\n          6'b100101: alu_control = 4'b0001; // or\n          6'b101010: alu_control = 4'b0111; // slt\n          default: alu_control = 4'bxxxx; // undefined\n        endcase\n      end\n      default: alu_control = 4'bxxxx; // undefined\n    endcase\n  end\nendmodule",
    "answer": {
      "Performance": "The current design has undefined outputs (4'bxxxx) which can cause simulation issues and unpredictable synthesis results. Also, the nested case statements create a deep logic tree that increases delay. Flatten the logic and add a default value:\n\nalways @(*) begin\n  // Default assignment\n  alu_control = 4'b0000;\n  \n  case ({alu_op, funct})\n    // Load/store operations\n    {2'b00, 6'bxxxxxx}: alu_control = 4'b0010; // add\n    \n    // Branch operations\n    {2'b01, 6'bxxxxxx}: alu_control = 4'b0110; // sub\n    \n    // R-type operations\n    {2'b10, 6'b100000}: alu_control = 4'b0010; // add\n    {2'b10, 6'b100010}: alu_control = 4'b0110; // sub\n    {2'b10, 6'b100100}: alu_control = 4'b0000; // and\n    {2'b10, 6'b100101}: alu_control = 4'b0001; // or\n    {2'b10, 6'b101010}: alu_control = 4'b0111; // slt\n    // Add other instructions as needed\n  endcase\nend\n\nThis flattened approach reduces logic levels in the critical path.",
      "Power": "The 'x' states can cause excessive toggling in simulation and unpredictable power behavior in synthesis. Adding a default assignment prevents unwanted switching. A lookup table (LUT) implementation is more power-efficient than the cascaded case statements in the original design, as fewer gates toggle during operation.",
      "Area": "The flattened case statement allows the synthesis tool to better optimize the logic, potentially reducing the area. Adding a default assignment prevents the synthesis tool from inferring latches, which would consume unnecessary area. For a small control unit like this, the area impact is minimal but important for clean synthesis."
    }
  }
]
